Проект: микросервисное приложение с логированием и CI/CD



Идея: создать мини-систему из двух микросервисов

frontend - простой веб-интерфейс на Flask or React

backend - API сервис на Flask, сохраняющий логи запросов в файл или базу данных (SQLite or MongoDB)

отдельный nginx для проксирования или статики (???)

Все будет запускаться через docker-compose, используется volume, networks и настраивается CI/CD через GitHub Actions



Структура проекта: 



docker-logging-app/

│

├── frontend/

│   ├── Dockerfile

│   ├── app/

│   │   └── index.html / app.py

│

├── backend/

│   ├── Dockerfile

│   ├── app/

│   │   └── main.py (с API + логика логирования)

│   │   └── logs/ (volume для логов)

│

├── nginx/

│   ├── nginx.conf

│   └── Dockerfile (опционально)

│

├── docker-compose.yml

├── .github/workflows/deploy.yml

└── README.md



Цель: изучить в процессе

Dockerfile - напишу Dockerfile для каждого сервиса

Docker Compose - настрою докер компос с общими томами, сетями

Volumes - использую томы для логов и передачи данных между сервисами

Docker Networks - настрою bridge-сети и увижу, как контейнеры взаимодействуют

Log rotation - настрою хронение логов с ротацией 

Nginx - настрою проксирование с фронтенда на бекенд

CI/CD - сборка и пуш образов в Docker Hub or ACR

Secrets - добавлю секреты в git

README - составлю документацию проекта и как его запускать



Шаг 1: пишу docker-compose file

Это файл, в котором я должен описать все сервисы своего проекта, как они строятся, соединяются, обмениваются данными, и какие порты открывают. Это центральное место для управления многоконтейнерными приложениями. Пишется на языке YAML - язык данных, чувствивтельный к отступам. Отступы делаются только пробелами. Нужно использовать 2 пробела на уровень вложенности. Например: 

services:

&nbsp; frontend:

&nbsp;   build: ./frontend



Разбор файла docker compose 

version: "3.8"



services:

&nbsp; frontend:

&nbsp;   build: ./frontend

&nbsp;   ports:

&nbsp;     - "80:80"

&nbsp;   depends\_on:

&nbsp;     - backend

&nbsp;   networks:

&nbsp;     - app-network



&nbsp; backend:

&nbsp;   build: ./backend

&nbsp;   volumes:

&nbsp;     - logs-volume:/app/logs

&nbsp;   expose:

&nbsp;     - "5000"

&nbsp;   networks:

&nbsp;     - app-network



&nbsp; nginx:

&nbsp;   image: nginx:latest

&nbsp;   ports:

&nbsp;     - "8080:80"

&nbsp;   volumes:

&nbsp;     - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro

&nbsp;   depends\_on:

&nbsp;     - frontend

&nbsp;   networks:

&nbsp;     - app-network



volumes:

&nbsp; logs-volume:



networks:

&nbsp; app-network:

&nbsp;   driver: bridge



**Frontend часть**

1\) version: "3.8" - указывает версию синтаксиса docker-compose.

2\) services: это секция, где ты описываешь все контейнеры, которые нужно поднять. У нас: frontend, backend, nginx

3\) build говорит Docker: собери образ из Dockerfile, находящегося в папке ./frontend

4\) Пробрасываем порт хоста 80 внутрь контейнера на порт 80. Это как "открыть окно наружу".

5\) Скажи Docker Compose: "не запускай frontend, пока не готов backend". Это не означает, что backend уже принимает запросы — просто контейнер запущен.

6\) Контейнер подключён к одной общей виртуальной сети, чтобы они могли друг друга "видеть" по имени.



**Backend часть:** 

1\) Сборка образа из Dockerfile в папке ./backend

2\) Подключаем том logs-volume к папке /app/logs в контейнере.

3\) Все логи будут сохраняться снаружи контейнера, и ты сможешь их читать даже после перезапуска.

4\) Этот порт (5000) будет доступен другим контейнерам внутри сети, но не извне. То есть nginx сможет достучаться, но ты снаружи — нет. (В отличие от ports, которые публикуют наружу.)

5\) Контейнер подключён к одной общей виртуальной сети, чтобы они могли друг друга "видеть" по имени.



**Nginx часть:**

1\) Вместо сборки мы используем официальный образ nginx.

2\) Открываем наружу порт 8080 (локально), который будет направлен в 80 внутри контейнера (где слушает nginx).

3\) Монтируем свой конфиг nginx.conf внутрь контейнера по пути, где nginx его ищет. По умолчанию nginx ничего не знает про мои сервисы и не знает, что мне нужно проксирование на frontend and backed. Для этого мы берем наш конфиг, в котором описали что и куда проксировать и подсовываем его в стандартное место /etc/nginx/nginx.conf. Мы нуждаемся в проксирование потому, что это процесс, когда один сервис перенаправляет входящий запрос на другой сервер и затем отдает клиенту результат от имени себя. Я хочу, чтобы frontend занимался показом HTML or UI, a backend занимался обработкой данных и логикой. Но пользователь не должен знать на каком порту у меня работает backend и какие у меня микросервисы. Я прячу все это за одним входом - nginx. Он принимает запросы и перенаправляет их в нужный контейнер. Благодаря этому только nginx открыт наружу, остальные контейнеры доступны только внутри docker-cети. nginx как секретарь обращается со своими контейнерами, которые мы описали в его конф. Если путь /api - направляет на backend, если путь / - отдает HTML из frontend. Без проксирования мне бы пришлось открывать разные порты, настраивать CORS (разрешения на запросы между разными портами) и это все неудобно, как сервисов все больше

4\) :ro — read-only (не даём контейнеру право его менять).



**volumes:**

Создаём именованный volume, чтобы сохранить файлы (логи) между перезапусками контейнеров.



**Networks:** 

Создаём виртуальную сеть, внутри которой контейнеры могут обращаться друг к другу по имени (backend, frontend, nginx).



Проверка на корректность: docker-compose up --build

Если все будет правильно, то увижу логи сборки и запуска. Если есть ошибка, она будет скорее всего связана с отступами, неправильными путями или ошибкой в dockerfile or nginx.conf



**Шаг 2: создаем наш бэк и фронт. Пишу к ним dockerfile и запускаю архитектуру в контейнере**

Flask приложение on python для backend:



from flask import Flask, request

import datetime

import os



app = Flask(\_\_name\_\_)



LOG\_DIR = "logs"

os.makedirs(LOG\_DIR, exist\_ok=True)



@app.route("/")

def home():

&nbsp;   return "Backend is running", 200



@app.route("/log", methods=\["POST"])

def log():

&nbsp;   content = request.get\_json()

&nbsp;   with open(f"{LOG\_DIR}/log.txt", "a") as f:

&nbsp;       f.write(f"{datetime.datetime.now()}: {content}\\n")

&nbsp;   return {"status": "logged"}, 200



if \_\_name\_\_ == "\_\_main\_\_":

&nbsp;   app.run(host="0.0.0.0", port=5000)



Flask - это очень простой веб-фреймворк на python, с помощью которого можно запускать сервер, обрабатывать http-запросы и отдавать ответы

1\) подключаем нужные модули - flask, request - читать, что прислал пользователь, datetime - записывать дату и время в логи, os - работа с файлами и папками

2\) создаем эксземпляр flask - приложения, называем его app. Моя точка входа в веб-приложения 

3\) пишем код для проверки папки logs, если уже есть - не ругайся

4\) если пользователь заходит по адресу /, мы отправим: текст backend is running и стутус 200 (ОК). К примеру, если зайти по адресу curl http://localhost:5000/ -> получаем backend is running

5\) 

@app.route("/log", methods=\["POST"]) - создаем маршрут /log, который принимает POST-запросы (то есть данные, а не просто заход в браузер)

def log():

&nbsp;   content = request.get\_json() - берем JSON данные, которые прислал пользователь

&nbsp;   with open(f"{LOG\_DIR}/log.txt", "a") as f: - открываем файл logs/log.txt для дозаписи - a = append

&nbsp;       f.write(f"{datetime.datetime.now()}: {content}\\n") - пишем в файл текущую дату и то, что пользователь прислал

&nbsp;   return {"status": "logged"}, 200 - отправляем обратно JSON - ответ

6\) последняя часть - запуск сервера Flask. host 0.0.0.0 - означает: слушай на всех IP-адресах внутри контейнера (чтобы был доступ из других контейнеров) и выбрал порт 5000 (типично для фляска). if \_\_name\_\_ == "\_\_main\_\_": - проверяет, запущен ли файл напрямую. Помогает избежать нежелательно запуска кода при импорте. Нам нужна эта строка, чтобы код внутри нее выполнялся только при запуска файла напрямую, а не при его импорте как модуля, это помогает разделить поведение исполняемого скрипта и библиотеки. Это помогает нам сделать один и тот же файл и испоняемым, и импортируетмым, не мешая логике



**Dockerfile backend:** 

FROM python:3.10-slim



WORKDIR /app - устанавливаем рабочую директорию внутри контейнера, даем понятное название

&nbsp;

COPY /app /app/ - копируем с нашей папки апп в контейнер апп



RUN pip install flask



CMD \["python", "main.py"]



**Frontend HTML  -** пишу самый банальный, простой HTML файл для контента на странице 

<!DOCTYPE html>

<html lang="en">

<head>

&nbsp; <meta charset="UTF-8">

&nbsp; <title>Frontend</title>

</head>

<body>

&nbsp; <h1>Hello from Frontend!</h1>

&nbsp; <p>This is served by Nginx in a Docker container.</p>

</body>

</html>



**Dockerfile frontend:**

FROM nginx:alpine



COPY app/index.html /usr/share/nginx/html/index.html



Такой простой dockerfile, потому что nginx уже умеет обслуживать HTML-файлы, нам не нужен сервер. Это быстрый способ раздать статику (например, лендинги, SPA). Мы можем заменить этот frontend позже на React/Vue и просто копировать build/ папку туда



Шаг 4: подключить nginx как reverse proxy

Frontend отдает статику сам по себе на порт 80, backend слушает на порту 5000 внутри контейнера, но пользователь не знает, куда идти: frontend and backend не связаны снаружи. Я хочу, чтобы пользовать просто заходил на страницу фронта, а мой nginx уже: отдавал /index.html с фронта и проксировал /api/log на backend

План: создать конфиг файл nginx.conf, добавить его в nginx/ и подключить в docker-compose.yml и убедиться, что nginx правильно напрвляет трафик на front and back



events {}



http {

&nbsp; server {

&nbsp;   listen 80;



&nbsp;   # Отдаём frontend

&nbsp;   location / {

&nbsp;     proxy\_pass http://frontend:80;

&nbsp;   }



&nbsp;   # Проксируем на backend

&nbsp;   location /api/ {

&nbsp;     proxy\_pass http://backend:5000/;

&nbsp;   }

&nbsp; }

}



location / - все, что не начинается с /api/ - > frontend

location /api/ - все, что начинается с /api/ -> backend

Имена frontend and backend - это имена сервисов в docker-compose, которые видны внутри "app-network"



После этого можно запускать наш docker compose: docker compose up --build и проверять работу фронта и бека. Для фронта переходим на страницу, где получаем our HTML's. Для бека в power shell отправляем 

Invoke-RestMethod -Uri http://localhost:8081/api/log -Method POST -Body '{"msg":"Hello"}' -ContentType "application/json"



После проверки все работает корректно 

Проблемы: порт 80 был занят, поэтому я перекинул на порт 81. Порты на фронте и на беке я убрал, потому что нет такой надобности оставлять их наружу. В случае nginx достаточно дать ему порт для общения снаружи. А сами по себе контейнеры могут общаться с помощью сети. В файле nginx.cong я описал на каком порта искать фронт и бек 

location / {

&nbsp; proxy\_pass http://frontend:80;

}



location /api/ {

&nbsp; proxy\_pass http://backend:5000;

}

Nginx будеть искать DNS-имя frontend или backend внутри своей Docker-сети (в нашем случае app-network) и подключаться к ним по указанному порту 80 или 5000.

Причина, по которой я не видел записанные пост логи в беке - они записывались внутри контейнера, а не на моей локальной машине. Для того, чтобы посмотреть логи нужно интерактивно подключитсья к контейнеру и открыть папку с лоагми. В логах я вижу сообщения, которые локально отправлял со своей машины. Так же есть возможность скопировать файл с логами на мою локальную машину с помощью docker cp.



Итоги: Я научился писать docker-compose.yml и запускать с него сразу несколько контейнеров. Описал структуру каждого сервиса внутри этого файла, а также подключил custom network для внутреннего общения между контейнерами и volume-томы для логирования и передачи данных.



В backend-сервисе я подключил именованный volume для записи логов. Для nginx я создал и подключил собственный конфигурационный файл (nginx.conf), через который настроил reverse proxy на frontend и backend.



Я написал простое Flask-приложение для backend и базовый HTML-файл для frontend. Для каждого сервиса создал отдельный Dockerfile, описал процесс сборки контейнера и понял, как это работает изнутри — включая WORKDIR, CMD, COPY и базовые образы.



Использовал все ключевые сущности Docker Compose: services, networks, volumes, depends\_on, build



Понял назначение proxy\_pass, имен DNS в сети, внутренних портов и разницы между localhost и имя\_сервиса



&nbsp;Что такое volumes в Docker?

Volume — это способ сохранять данные вне контейнера, чтобы:



Данные не удалялись при пересоздании контейнера



Ими могли обмениваться несколько контейнеров



Ты мог получить доступ к этим данным с хост-машины или из другого контейнера



📉 Без volume — все данные исчезают

Контейнер = временный, одноразовый процесс.



Если внутри контейнера у тебя файл /app/logs/log.txt, то:



он будет жить только пока жив контейнер



при docker compose down или docker rm — всё исчезнет



📌 Это значит: логирование, базы данных, кэш, конфигурации — всё будет утеряно, если ты не используешь volume.



✅ Когда обязательно использовать volumes

Use Case	Почему нужен volume

📑 Логи	Чтобы не потерять записи между перезапусками

🗃️ База данных	Данные не должны исчезать при обновлении контейнера

🧪 Обмен файлами	Несколько сервисов пишут/читают в одно место

🔍 Конфигурации	Ты хочешь менять конфиг без пересборки образа



🔧 Типы volumes в Docker Compose

1\. Named volume (именованный)

Это то, что ты уже использовал:



yaml

Копировать код

volumes:

&nbsp; - logs-volume:/app/logs

logs-volume — имя (Docker сам создаёт его и хранит где-то на диске, обычно /var/lib/docker/volumes/...)



/app/logs — путь внутри контейнера



Один и тот же volume можно подключить к нескольким контейнерам



📎 Внизу docker-compose.yml ты должен объявить:



yaml

Копировать код

volumes:

&nbsp; logs-volume:

2\. Bind mount (привязка к локальной папке)

yaml

Копировать код

volumes:

&nbsp; - ./backend/app/logs:/app/logs

Левая часть (./...) — это локальная папка на твоём компьютере



Правая часть (/app/logs) — путь в контейнере



Это удобно при разработке: ты можешь сразу видеть, что происходит



📊 Сравнение: named volume vs bind mount

Характеристика	Named Volume	Bind Mount (./folder)

Управляется Docker	✅ Да	❌ Нет (управляешь сам)

Кросс-платформенность	✅ Хорошая	⚠️ Зависит от ОС/пути

Доступ извне	❌ Сложно	✅ Просто смотреть в папке

Безопасность	✅ Изолирован	⚠️ Может быть уязвим

Удобство в проде	✅	❌ Лучше не использовать



🔍 Как выглядит backend без volume

Если ты не добавишь volume:



yaml

Копировать код

backend:

&nbsp; build: ./backend

→ Тогда логи пишутся внутрь контейнера (например, /app/logs/log.txt)

→ И исчезнут при docker compose down или docker rm



🧪 Как проверить volume

bash

Копировать код

docker volume ls            # список томов

docker volume inspect имя   # где реально лежит

docker volume rm имя        # удалить

✅ Вывод — когда использовать volume

Используй volume, когда тебе нужно сохранить состояние, которое не должно исчезнуть при перезапуске контейнера: это лог-файлы, базы данных, конфиги, кэш — всё, что важно для работы приложения долгосрочно.





